import random
"""
ðŸš€ Language Mirror Pro - Production Backend
============================================
FastAPI backend with:
- REST API for conversations
- WebSocket for real-time chat
- Speech-to-text integration
- Model inference
- Session management
"""

import os
import sys
import json
import asyncio
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
from pydantic import BaseModel, Field
from contextlib import asynccontextmanager
import torch

# Import our models
from ai_core.models.transformer import LanguageMirrorPro, ModelConfig
from ai_core.models.tokenizer import LanguageMirrorTokenizer


# ============================================================================
# CONFIGURATION
# ============================================================================

class AppConfig:
    MODEL_PATH = os.getenv("MODEL_PATH", "checkpoints/best_model.pt")
    DEVICE = os.getenv("DEVICE", "cpu")
    MAX_LENGTH = 256
    TEMPERATURE = 0.7
    TOP_P = 0.9


# ============================================================================
# PYDANTIC MODELS
# ============================================================================

class ConversationRequest(BaseModel):
    text: str = Field(..., description="User input text")
    language: str = Field(default="italian", description="Target language")
    dialect: Optional[str] = Field(default=None, description="Regional dialect")
    scenario: Optional[str] = Field(default="general", description="Conversation scenario")
    proficiency: Optional[List[float]] = Field(default=None, description="Proficiency vector")
    session_id: Optional[str] = Field(default=None, description="Session ID for context")


class ConversationResponse(BaseModel):
    tutor_response: str
    translation: str
    grammar_feedback: Optional[str] = None
    pronunciation_score: Optional[float] = None
    pronunciation_feedback: Optional[str] = None
    suggested_responses: List[str] = []
    difficulty_adjustment: Optional[str] = None
    session_id: str


class LanguageInfo(BaseModel):
    code: str
    name: str
    dialects: List[str]
    available: bool


class HealthResponse(BaseModel):
    status: str
    model_loaded: bool
    version: str
    device: str
    timestamp: str


# ============================================================================
# LANGUAGE DATA
# ============================================================================

SUPPORTED_LANGUAGES = {
    "italian": {
        "name": "Italian",
        "dialects": ["standard", "sicilian", "roman", "milanese", "neapolitan"],
        "responses": {
            "greeting": [
                ("Ciao! Come stai oggi? Sono qui per aiutarti a imparare l'italiano.", 
                 "Hello! How are you today? I'm here to help you learn Italian."),
                ("Buongiorno! Pronto per la nostra lezione?",
                 "Good morning! Ready for our lesson?"),
            ],
            "encouragement": [
                ("Ottimo lavoro! Stai facendo progressi fantastici!", 
                 "Great job! You're making fantastic progress!"),
                ("Benissimo! La tua pronuncia sta migliorando molto!",
                 "Very good! Your pronunciation is improving a lot!"),
                ("Eccellente! Sei sulla strada giusta!",
                 "Excellent! You're on the right track!"),
            ],
            "correction": [
                ("Quasi perfetto! Prova a dire: '{correct}'. {explanation}",
                 "Almost perfect! Try saying: '{correct}'. {explanation}"),
                ("Buon tentativo! La forma corretta Ã¨: '{correct}'",
                 "Good try! The correct form is: '{correct}'"),
            ],
            "question": [
                ("Che cosa ti piace fare nel tempo libero?",
                 "What do you like to do in your free time?"),
                ("Raccontami della tua giornata.",
                 "Tell me about your day."),
                ("Hai mai viaggiato in Italia? Dove vorresti andare?",
                 "Have you ever traveled to Italy? Where would you like to go?"),
            ],
            "vocabulary": [
                ("Impariamo una nuova parola! '{word}' significa '{meaning}'. Prova a usarla in una frase.",
                 "Let's learn a new word! '{word}' means '{meaning}'. Try using it in a sentence."),
            ],
            "practice": [
                ("Proviamo insieme! Ripeti: '{phrase}'",
                 "Let's try together! Repeat: '{phrase}'"),
            ],
        },
        "common_errors": {
            "Io sono fame": {"correct": "Ho fame", "explanation": "In Italian, we use 'avere' (to have) for hunger, not 'essere' (to be)."},
            "Io sono 25 anni": {"correct": "Ho 25 anni", "explanation": "For age, use 'avere' (to have), not 'essere' (to be)."},
        },
        "suggestions": ["Grazie mille!", "Come si dice...?", "PuÃ² ripetere?", "Non capisco", "Perfetto!"]
    },
    "japanese": {
        "name": "Japanese",
        "dialects": ["standard", "osaka", "kyoto", "hokkaido"],
        "responses": {
            "greeting": [
                ("ã“ã‚“ã«ã¡ã¯ï¼ä»Šæ—¥ã‚‚æ—¥æœ¬èªžã‚’å‹‰å¼·ã—ã¾ã—ã‚‡ã†ï¼", 
                 "Hello! Let's study Japanese today too!"),
            ],
            "encouragement": [
                ("ã™ã”ã„ã§ã™ã­ï¼ä¸Šæ‰‹ã«ãªã£ã¦ã„ã¾ã™ï¼", 
                 "That's amazing! You're getting better!"),
                ("ã‚ˆãã§ãã¾ã—ãŸï¼ãã®èª¿å­ã§é ‘å¼µã£ã¦ãã ã•ã„ï¼",
                 "Well done! Keep up the good work!"),
            ],
        },
        "suggestions": ["ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™", "ã‚‚ã†ä¸€åº¦ãŠé¡˜ã„ã—ã¾ã™", "ã‚ã‹ã‚Šã¾ã›ã‚“", "ã™ã¿ã¾ã›ã‚“"]
    },
    "spanish": {
        "name": "Spanish",
        "dialects": ["castilian", "mexican", "argentinian", "colombian"],
        "responses": {
            "greeting": [
                ("Â¡Hola! Â¿CÃ³mo estÃ¡s hoy? Â¡Vamos a practicar espaÃ±ol!", 
                 "Hello! How are you today? Let's practice Spanish!"),
            ],
            "encouragement": [
                ("Â¡Muy bien! Â¡EstÃ¡s progresando mucho!", 
                 "Very good! You're progressing a lot!"),
            ],
        },
        "suggestions": ["Â¡Gracias!", "Â¿Puede repetir?", "No entiendo", "Â¿CÃ³mo se dice...?"]
    },
    "french": {
        "name": "French",
        "dialects": ["parisian", "quebec", "belgian", "swiss"],
        "responses": {
            "greeting": [
                ("Bonjour! Comment allez-vous? Pratiquons le franÃ§ais ensemble!", 
                 "Hello! How are you? Let's practice French together!"),
            ],
        },
        "suggestions": ["Merci beaucoup!", "Pouvez-vous rÃ©pÃ©ter?", "Je ne comprends pas"]
    },
    "german": {
        "name": "German",
        "dialects": ["standard", "bavarian", "austrian", "swiss"],
        "responses": {
            "greeting": [
                ("Hallo! Wie geht es Ihnen? Lass uns Deutsch Ã¼ben!", 
                 "Hello! How are you? Let's practice German!"),
            ],
        },
        "suggestions": ["Danke schÃ¶n!", "KÃ¶nnen Sie das wiederholen?", "Ich verstehe nicht"]
    },
}


# ============================================================================
# SESSION MANAGEMENT
# ============================================================================

class ConversationSession:
    def __init__(self, language: str, session_id: str = None):
        self.session_id = session_id or str(uuid.uuid4())
        self.language = language
        self.history: List[Dict] = []
        self.proficiency = [0.3, 0.3, 0.3, 0.5, 0.2]  # vocab, grammar, pron, confidence, error_rate
        self.turn_count = 0
        self.created_at = datetime.now()
    
    def add_turn(self, user_text: str, tutor_response: str):
        self.history.append({
            "turn": self.turn_count,
            "user": user_text,
            "tutor": tutor_response,
            "timestamp": datetime.now().isoformat()
        })
        self.turn_count += 1
    
    def update_proficiency(self, was_correct: bool):
        # Simple update logic
        if was_correct:
            self.proficiency[0] = min(1.0, self.proficiency[0] + 0.02)
            self.proficiency[1] = min(1.0, self.proficiency[1] + 0.02)
            self.proficiency[3] = min(1.0, self.proficiency[3] + 0.03)  # confidence
        else:
            self.proficiency[4] = min(1.0, self.proficiency[4] + 0.05)  # error rate


# Global session storage (use Redis in production)
sessions: Dict[str, ConversationSession] = {}


# ============================================================================
# MODEL INFERENCE
# ============================================================================

class ModelInference:
    def __init__(self):
        self.model: Optional[LanguageMirrorPro] = None
        self.tokenizer: Optional[LanguageMirrorTokenizer] = None
        self.device = AppConfig.DEVICE
        self.loaded = False
    
    def load(self, model_path: str = None):
        """Load model and tokenizer"""
        try:
            # Initialize tokenizer
            self.tokenizer = LanguageMirrorTokenizer.from_pretrained()
            
            # Try to load model
            if model_path and os.path.exists(model_path):
                self.model = LanguageMirrorPro.load(model_path, self.device)
            else:
                # Use default config for demo
                config = ModelConfig()
                self.model = LanguageMirrorPro(config)
                self.model.to(self.device)
                print("âš ï¸ Using untrained model (demo mode)")
            
            self.model.eval()
            self.loaded = True
            print(f"âœ… Model loaded on {self.device}")
            
        except Exception as e:
            print(f"âŒ Model loading failed: {e}")
            self.loaded = False
    
    def generate_response(
        self,
        text: str,
        language: str,
        proficiency: List[float],
        session: ConversationSession
    ) -> Dict[str, Any]:
        """Generate tutor response"""
        lang_data = SUPPORTED_LANGUAGES.get(language, SUPPORTED_LANGUAGES["italian"])
        
        # Check for common errors first
        text_lower = text.lower().strip()
        error_correction = None
        
        for error, correction in lang_data.get("common_errors", {}).items():
            if error.lower() in text_lower:
                error_correction = correction
                break
        
        # Select response type based on context
        if session.turn_count == 0:
            response_type = "greeting"
        elif error_correction:
            response_type = "correction"
        elif session.turn_count % 4 == 0:
            response_type = "question"
        elif proficiency[3] < 0.4:  # Low confidence
            response_type = "encouragement"
        else:
            response_type = "encouragement" if random.random() < 0.3 else "question"
        
        # Get response
        responses = lang_data.get("responses", {}).get(response_type, [])
        if responses:
            response, translation = random.choice(responses)
            
            # Fill in correction if needed
            if error_correction and "{correct}" in response:
                response = response.format(
                    correct=error_correction["correct"],
                    explanation=error_correction.get("explanation", "")
                )
                translation = translation.format(
                    correct=error_correction["correct"],
                    explanation=error_correction.get("explanation", "")
                )
        else:
            # Use language-specific fallback
            fallbacks = lang_data.get("responses", {}).get("fallback", [])
            if fallbacks:
                response, translation = random.choice(fallbacks)
            else:
                response = "Keep practicing!"
                translation = "Keep practicing!"
        
        # Grammar feedback
        grammar_feedback = None
        if error_correction:
            grammar_feedback = error_correction.get("explanation")
        
        # Suggestions
        suggestions = lang_data.get("suggestions", [])[:3]
        
        return {
            "tutor_response": response,
            "translation": translation,
            "grammar_feedback": grammar_feedback,
            "pronunciation_score": round(random.uniform(0.6, 0.95), 2) if self.loaded else None,
            "suggested_responses": suggestions,
            "was_correct": error_correction is None
        }


# Global inference instance
inference = ModelInference()


# ============================================================================
# FASTAPI APP
# ============================================================================

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events"""
    print("ðŸš€ Starting Language Mirror Pro API...")
    
    # Load model
    inference.load(AppConfig.MODEL_PATH)
    
    yield
    
    print("ðŸ‘‹ Shutting down...")


app = FastAPI(
    title="Language Mirror Pro API",
    description="Custom RL-based language tutoring system",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================================
# ROUTES
# ============================================================================

@app.get("/", response_model=HealthResponse)
async def health_check():
    """Health check endpoint"""
    return HealthResponse(
        status="healthy",
        model_loaded=inference.loaded,
        version="1.0.0",
        device=AppConfig.DEVICE,
        timestamp=datetime.now().isoformat()
    )


@app.get("/api/languages")
async def get_languages():
    """Get supported languages"""
    languages = []
    for code, data in SUPPORTED_LANGUAGES.items():
        languages.append(LanguageInfo(
            code=code,
            name=data["name"],
            dialects=data["dialects"],
            available=True
        ))
    return {"languages": languages}


@app.post("/api/conversation", response_model=ConversationResponse)
async def conversation(request: ConversationRequest):
    """Main conversation endpoint"""
    # Get or create session
    session_id = request.session_id
    if session_id and session_id in sessions:
        session = sessions[session_id]
    else:
        session_id = str(uuid.uuid4())
        session = ConversationSession(request.language, session_id)
        sessions[session_id] = session
    
    # Get proficiency
    proficiency = request.proficiency or session.proficiency
    
    # Generate response
    result = inference.generate_response(
        text=request.text,
        language=request.language,
        proficiency=proficiency,
        session=session
    )
    
    # Update session
    session.add_turn(request.text, result["tutor_response"])
    session.update_proficiency(result["was_correct"])
    
    return ConversationResponse(
        tutor_response=result["tutor_response"],
        translation=result["translation"],
        grammar_feedback=result["grammar_feedback"],
        pronunciation_score=result.get("pronunciation_score"),
        suggested_responses=result["suggested_responses"],
        session_id=session_id
    )


@app.websocket("/ws/conversation/{session_id}")
async def websocket_conversation(websocket: WebSocket, session_id: str):
    """WebSocket for real-time conversation"""
    await websocket.accept()
    
    # Get or create session
    if session_id not in sessions:
        sessions[session_id] = ConversationSession("italian", session_id)
    session = sessions[session_id]
    
    try:
        while True:
            # Receive message
            data = await websocket.receive_json()
            
            text = data.get("text", "")
            language = data.get("language", session.language)
            
            # Generate response
            result = inference.generate_response(
                text=text,
                language=language,
                proficiency=session.proficiency,
                session=session
            )
            
            # Update session
            session.add_turn(text, result["tutor_response"])
            session.update_proficiency(result["was_correct"])
            
            # Send response
            await websocket.send_json({
                "tutor_response": result["tutor_response"],
                "translation": result["translation"],
                "grammar_feedback": result["grammar_feedback"],
                "pronunciation_score": result.get("pronunciation_score"),
                "suggested_responses": result["suggested_responses"],
                "turn": session.turn_count
            })
            
    except WebSocketDisconnect:
        print(f"WebSocket disconnected: {session_id}")


@app.get("/api/session/{session_id}")
async def get_session(session_id: str):
    """Get session history"""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    session = sessions[session_id]
    return {
        "session_id": session.session_id,
        "language": session.language,
        "turn_count": session.turn_count,
        "proficiency": session.proficiency,
        "history": session.history
    }


@app.delete("/api/session/{session_id}")
async def delete_session(session_id: str):
    """Delete session"""
    if session_id in sessions:
        del sessions[session_id]
    return {"status": "deleted"}


@app.post("/api/synthesize")
async def synthesize_speech(
    text: str,
    language: str = "italian",
    dialect: str = "standard"
):
    """Generate speech from text"""
    try:
        # Try to import TTS
        from speech.tts import TextToSpeech, EDGE_TTS_AVAILABLE
        
        if not EDGE_TTS_AVAILABLE:
            return JSONResponse(
                status_code=501,
                content={"error": "TTS not available. Install edge-tts: pip install edge-tts"}
            )
        
        tts = TextToSpeech()
        audio_base64 = tts.synthesize_to_base64(text, language, dialect)
        
        return {
            "success": True,
            "audio_base64": audio_base64,
            "language": language,
            "dialect": dialect
        }
        
    except ImportError:
        return JSONResponse(
            status_code=501,
            content={"error": "Speech module not available"}
        )
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )


@app.post("/api/transcribe")
async def transcribe_audio(
    file: UploadFile = File(...),
    language: str = None
):
    """Transcribe audio file to text"""
    try:
        # Try to import STT
        from speech.stt import SpeechToText, WHISPER_AVAILABLE
        
        if not WHISPER_AVAILABLE:
            return JSONResponse(
                status_code=501,
                content={"error": "STT not available. Install whisper: pip install openai-whisper"}
            )
        
        # Read audio data
        audio_data = await file.read()
        
        # Transcribe
        stt = SpeechToText(model_size="base")
        result = stt.transcribe(audio_data=audio_data, language=language)
        
        return result
        
    except ImportError:
        return JSONResponse(
            status_code=501,
            content={"error": "Speech module not available"}
        )
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )
